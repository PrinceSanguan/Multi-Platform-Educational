import { Readable, Writable } from 'stream';

/* eslint-disable stylistic/indent */ /* eslint-disable no-labels */ // https://www.gnu.org/software/tar/manual/html_node/Standard.html
// https://www.gnu.org/software/tar/manual/html_node/Portability.html#Portability
const Mode = {
    TS_UID: 0o4000,
    TS_GID: 0o2000,
    TS_VTX: 0o1000,
    TU_READ: 0o0400,
    TU_WRITE: 0o0200,
    TU_EXEC: 0o0100,
    TG_READ: 0o0040,
    TG_WRITE: 0o0020,
    TG_EXEC: 0o0010,
    TO_READ: 0o0004,
    TO_WRITE: 0o0002,
    TO_EXEC: 0o0001
};
const F_MODE = Mode.TU_READ | Mode.TU_WRITE | Mode.TG_READ | Mode.TO_READ;
const D_MODE = Mode.TU_READ | Mode.TU_WRITE | Mode.TU_EXEC | Mode.TG_READ | Mode.TG_EXEC | Mode.TO_READ | Mode.TO_EXEC;
const TypeFlag = {
    REG_TYPE: '0',
    AREG_TYPE: '\0',
    LINK_TYPE: '1',
    SYM_TYPE: '2',
    CHR_TYPE: '3',
    BLK_TYPE: '4',
    DIR_TYPE: '5',
    FIFO_TYPE: '6',
    CONT_TYPE: '7',
    // For Pax
    XHD_TYPE: 'x',
    XGL_TYPE: 'g'
};
const Magic = {
    T_MAGIC: 'ustar',
    T_VERSION: '00',
    WHITE_SPACE: 32,
    EQ_CHAR: 61,
    NULL_CHAR: 0,
    NEW_LINE: 10,
    NEGATIVE_256: 0xFF,
    POSITIVE_256: 0x80
};
const ERROR_MESSAGES = {
    INVALID_ENCODING_NAME: "Invalid name. Invalid name. Please check 'name' is a directory type.",
    INVALID_ENCODING_NAME_LEN: "Invalid name. Please check 'name' length is less than 255 byte.",
    INVALID_ENCODING_LINKNAME: "Invalid linkname. Please check 'linkname' length is less than 100 byte.",
    INVALID_BASE256: 'Invalid base256 format',
    INVALID_OCTAL_FORMAT: 'Invalid octal format',
    NOT_INIT: 'Not init',
    INVALID_CHKSUM: 'Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?'
};
// For most scens. format ustar is useful, but when we meet the large file, we should fallback to the old gnu format.
const enc = /* @__PURE__ */ new TextEncoder();
const encodeString = enc.encode.bind(enc);
function decodeString(b, offset, length, encoding = 'utf-8') {
    // filter null character
    while(b[offset + length - 1] === Magic.NULL_CHAR){
        length--;
    }
    const dec = new TextDecoder(encoding);
    return dec.decode(b.subarray(offset, offset + length));
}
function encodeOctal(b, fixed) {
    const o = b.toString(8);
    if (fixed) {
        if (o.length <= fixed) {
            const fill = '0'.repeat(fixed - o.length);
            return fill + o + ' ';
        }
        return '7'.repeat(fixed) + ' ';
    }
    return o;
}
// https://www.gnu.org/software/tar/manual/html_node/Extensions.html
function parse256(b) {
    const positive = b[0] === Magic.POSITIVE_256 ? true : false;
    return b.slice(1).reduceRight((acc, cur, i)=>{
        const byte = positive ? cur : Magic.NEGATIVE_256 - cur;
        return acc += byte * Math.pow(256, b.length - i - 2);
    }, 0) * (positive ? 1 : -1);
}
function decodeOctal(b, offset, length) {
    const range = b.subarray(offset, offset + length);
    // for old gnu format
    if (range[0] & Magic.POSITIVE_256) {
        if (range[0] === Magic.POSITIVE_256 || range[0] === Magic.NEGATIVE_256) {
            return parse256(range);
        }
        throw new Error(ERROR_MESSAGES.INVALID_BASE256);
    }
    // [48...48, 32, 0] // len = 8
    let pos = 0;
    for(;;){
        if (range[pos] === Magic.WHITE_SPACE) {
            break;
        }
        if (pos >= length) {
            throw new Error(ERROR_MESSAGES.INVALID_OCTAL_FORMAT);
        }
        pos++;
    }
    return parseInt(decodeString(range, 0, pos), 8);
}
// https://www.gnu.org/software/tar/manual/html_node/Checksumming.html#Checksumming
function chksum(b) {
    return b.subarray(0, 512).reduce((acc, cur, i)=>{
        if (i >= 148 && i < 156) {
            return acc + Magic.WHITE_SPACE;
        }
        return acc + cur;
    }, 0);
}
// "%d %s=%s\n", <length>, <keyword>, <value>
function paxTemplate(keyword, value) {
    const template = ' ' + keyword + '=' + value + '\n';
    const binary = encodeString(template);
    return binary.length + String(binary.length).length + template;
}
// https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_03
// Encode implements the Basic ustar format. But when the size is over 2^33, it will fallback to the posix pax format.
// | ustar Header[typeFlag=g]    |
// | Global Extended Header Data |
// | ustar Header[typeFlag=x]    |
// | Extended Header Data        |
// | ustar Header[typeFlag=0]    |
// | File Data                   |
// ...
function encode(options) {
    const block = new Uint8Array(512);
    let name = options.name;
    if (options.typeflag === TypeFlag.DIR_TYPE && name[name.length - 1] !== '/') {
        name += '/';
    }
    let prefix = '';
    let invalidate = false;
    loop: while(name.length > 100){
        const spec = name.indexOf('/');
        switch(spec){
            case -1:
                invalidate = true;
                break loop;
            default:
                {
                    const range = name.slice(0, spec);
                    prefix += prefix ? '/' + range : range;
                    name = name.slice(spec + 1);
                }
        }
    }
    if (invalidate) {
        throw new Error(ERROR_MESSAGES.INVALID_ENCODING_NAME);
    }
    const binaryName = encodeString(name);
    if (binaryName.length + prefix.length > 255) {
        throw new Error(ERROR_MESSAGES.INVALID_ENCODING_NAME_LEN);
    }
    if (options.linkname && encodeString(options.linkname).length > 100) {
        throw new Error(ERROR_MESSAGES.INVALID_ENCODING_LINKNAME);
    }
    block.set(binaryName, 0);
    block.set(encodeString(encodeOctal(options.mode, 6)), 100);
    block.set(encodeString(encodeOctal(options.uid, 6)), 108);
    block.set(encodeString(encodeOctal(options.gid, 6)), 116);
    // size
    // octal max is 7777777...
    if (options.size.toString(8).length > 11) {
        let s = options.size;
        const bb = [
            Magic.POSITIVE_256
        ];
        for(let i = 11; i > 0; i--){
            bb[i] = s & Magic.NEGATIVE_256;
            s = Math.floor(s / 256);
        }
        block.set(bb, 124);
    } else {
        block.set(encodeString(encodeOctal(options.size, 11)), 124);
    }
    block.set(encodeString(encodeOctal(options.mtime, 11)), 136);
    block.set(encodeString(options.typeflag), 156);
    if (options.linkname) {
        block.set(encodeString(options.linkname), 157);
    }
    // magic & version
    block.set(encodeString(Magic.T_MAGIC), 257);
    block.set(encodeString(Magic.T_VERSION), 263);
    // uname
    if (options.uname) {
        block.set(encodeString(options.uname), 265);
    }
    // gname
    if (options.gname) {
        block.set(encodeString(options.gname), 297);
    }
    block.set(encodeString(encodeOctal(options.devmajor, 6)), 329);
    block.set(encodeString(encodeOctal(options.devminor, 6)), 337);
    if (prefix) {
        block.set(encodeString(prefix), 345);
    }
    // chksum
    block.set(encodeString(encodeOctal(chksum(block), 6)), 148);
    return block;
}
function encodePax(options) {
    let p = '';
    p += paxTemplate('path', options.name);
    p += paxTemplate('linkpath', options.linkname);
    if (options.pax && typeof options.pax === 'object') {
        for(const key in options.pax){
            p += paxTemplate(key, options.pax[key]);
        }
    }
    return encodeString(p);
}
const defaultDecodeOptions = {
    filenameEncoding: 'utf-8'
};
function decode(b, options) {
    const opts = options = {
        ...defaultDecodeOptions,
        ...options
    };
    const { filenameEncoding } = opts;
    let name = decodeString(b, 0, 100, filenameEncoding);
    const mode = decodeOctal(b, 100, 8);
    const uid = decodeOctal(b, 108, 8);
    const gid = decodeOctal(b, 116, 8);
    const size = decodeOctal(b, 124, 12);
    const mtime = decodeOctal(b, 136, 12);
    // convert as enum
    let typeflag = b[156] === 0 ? TypeFlag.AREG_TYPE : b[156] === 120 ? TypeFlag.XHD_TYPE : b[156] === 103 ? TypeFlag.XGL_TYPE : b[156] - 48 + '';
    const linkname = b[157] === Magic.NULL_CHAR ? null : decodeString(b, 157, 100, filenameEncoding);
    const uname = decodeString(b, 265, 32);
    const gname = decodeString(b, 297, 32);
    const devmajor = decodeOctal(b, 329, 8);
    const devminor = decodeOctal(b, 337, 8);
    const c = chksum(b);
    if (c === 256) throw new Error(ERROR_MESSAGES.NOT_INIT);
    if (c !== decodeOctal(b, 148, 8)) {
        throw new Error(ERROR_MESSAGES.INVALID_CHKSUM);
    }
    //
    if (Magic.T_MAGIC === decodeString(b, 257, 6)) {
        if (b[345]) {
            name = decodeString(b, 345, 155, filenameEncoding) + '/' + name;
        }
    }
    if (typeflag === TypeFlag.REG_TYPE && name[name.length - 1] === '/') {
        typeflag = TypeFlag.DIR_TYPE;
    }
    return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime,
        typeflag,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
    };
}
function decodePax(b) {
    const pax = {};
    const matrix = [];
    let cap = b.length;
    let line = 0;
    if (!matrix[line]) {
        matrix[line] = [];
    }
    let start = 0;
    while(cap > 0){
        matrix[line].push(b[start]);
        if (b[start] === Magic.NEW_LINE) {
            if (start + 1 === b.length) break;
            line++;
            matrix[line] = [];
            start++;
            continue;
        }
        start++;
        cap--;
    }
    for(let i = 0; i < matrix.length; i++){
        const item = matrix[i];
        let pos = 0;
        while(item[pos] !== Magic.WHITE_SPACE && pos < item.length){
            pos++;
        }
        const bb = new Uint8Array(item);
        const len = parseInt(decodeString(bb, 0, pos)) - 1;
        const content = bb.subarray(pos + 1, len);
        const eqPos = content.indexOf(Magic.EQ_CHAR);
        Object.assign(pax, {
            [decodeString(content, 0, eqPos)]: decodeString(content, eqPos + 1, content.length)
        });
    }
    return pax;
}

/* eslint-disable no-use-before-define */ function _define_property$1(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class Elt {
    get leak() {
        return this.items[this.pos] !== undefined;
    }
    push(element) {
        this.items[this.pos] = element;
        this.pos = this.pos + 1 & this.mask;
    }
    shift() {
        const first = this.items[this.rev];
        if (first === undefined) return undefined;
        this.items[this.rev] = undefined;
        this.rev = this.rev + 1 & this.mask;
        return first;
    }
    peek() {
        return this.items[this.rev];
    }
    constructor(cap){
        _define_property$1(this, "items", void 0);
        _define_property$1(this, "pos", void 0);
        _define_property$1(this, "mask", void 0);
        _define_property$1(this, "rev", void 0);
        _define_property$1(this, "next", void 0);
        this.items = new Array(cap);
        this.pos = 0;
        this.rev = 0;
        this.mask = cap - 1;
        this.next = null;
    }
}
// A fast list implementation
class List {
    push(elt) {
        if (this.head.leak) {
            const prev = this.head;
            prev.next = new Elt(this.head.items.length * 2);
            this.head = prev.next;
        }
        this.head.push(elt);
        this.length++;
    }
    shift() {
        if (this.length !== 0) this.length--;
        const value = this.tail.shift();
        if (value === undefined && this.tail.next) {
            const next = this.tail.next;
            this.tail.next = null;
            this.tail = next;
            return this.tail.shift();
        }
        return value;
    }
    peek() {
        const v = this.tail.peek();
        if (v === undefined && this.tail.next) {
            return this.tail.next.peek();
        }
        return v;
    }
    constructor(cap = 16){
        _define_property$1(this, "cap", void 0);
        _define_property$1(this, "head", void 0);
        _define_property$1(this, "tail", void 0);
        _define_property$1(this, "length", void 0);
        this.cap = cap;
        this.length = 0;
        this.head = new Elt(this.cap);
        this.tail = this.head;
    }
}
function createList(cap) {
    return new List(16);
}

function noop() {}

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function createReadbleStream(options) {
    return new Readable(options);
}
function createWriteableStream(options) {
    return new Writable(options);
}
const PACK_ERROR_MESSAGES = {
    HAS_DONE: "Can't add new entry after calling done()"
};
// New archives should be created using REGTYPE.
const defaultPackOptions = {
    mode: F_MODE,
    uid: 0,
    gid: 0,
    typeflag: TypeFlag.REG_TYPE,
    devmajor: 0,
    devminor: 0
};
class Pack {
    resolveHeadOptions(size, options) {
        const { filename, ...rest } = options;
        return {
            ...defaultPackOptions,
            ...rest,
            name: filename,
            mtime: Math.floor(Date.now() / 1000),
            size
        };
    }
    add(binary, options) {
        if (this.finished) {
            throw new Error(PACK_ERROR_MESSAGES.HAS_DONE);
        }
        const resolved = this.resolveHeadOptions(binary.length, options);
        this.transport(binary, resolved);
    }
    done() {
        if (this.finished) return;
        this.finished = true;
        this.reader.push(new Uint8Array(1024));
        this.reader.push(null);
    }
    fix(size) {
        const padding = (512 - size % 512) % 512;
        if (padding > 0) this.reader.push(new Uint8Array(padding));
    }
    transport(binary, resolvedOptions) {
        const consume = (chunk)=>{
            if (resolvedOptions.pax) {
                const paxHead = encodePax({
                    name: resolvedOptions.name,
                    linkname: resolvedOptions.linkname || '',
                    pax: {
                        ...resolvedOptions.pax
                    }
                });
                const head = encode({
                    ...resolvedOptions,
                    name: 'PaxHeader',
                    typeflag: TypeFlag.XHD_TYPE,
                    size: paxHead.length
                });
                this.reader.push(head);
                this.reader.push(paxHead);
                this.reader.push(this.fix(paxHead.length));
                resolvedOptions.name = 'PaxHeader';
            }
            this.reader.push(encode(resolvedOptions));
            this.reader.push(chunk);
        };
        const writer = createWriteableStream({
            write: (chunk, _, callback)=>{
                try {
                    consume(chunk);
                    callback();
                } catch (error) {
                    callback(error);
                }
            },
            final: (callback)=>{
                this.reader.push(this.fix(resolvedOptions.size));
                callback();
            }
        });
        writer.write(binary, (e)=>{
            if (e) {
                this.reader.emit('error', e);
            }
        });
        writer.end();
    }
    get receiver() {
        return this.reader;
    }
    constructor(){
        _define_property(this, "reader", void 0);
        _define_property(this, "finished", void 0);
        this.reader = createReadbleStream({
            read () {}
        });
        this.finished = false;
    }
}
function createPack() {
    return new Pack();
}
const FAST_BYTES_ERROR_MESSAGES = {
    EXCEED_BYTES_LEN: 'The size of bytes exceeds the length of whole bytes.'
};
class FastBytes {
    push(b) {
        this.bytesLen += b.length;
        this.insertedBytesLen += b.length;
        this.queue.push(b);
    }
    shift(size) {
        if (size > this.bytesLen) {
            throw new Error(FAST_BYTES_ERROR_MESSAGES.EXCEED_BYTES_LEN);
        }
        if (size === 0) {
            return new Uint8Array(0);
        }
        const elt = this.queue.peek();
        if (!elt) {
            throw new Error(FAST_BYTES_ERROR_MESSAGES.EXCEED_BYTES_LEN);
        }
        const b = new Uint8Array(size);
        this.queue.shift();
        const bb = elt.subarray(size);
        if (bb.length > 0) {
            this.queue.push(bb);
        }
        b.set(elt.subarray(0, size));
        this.bytesLen -= size;
        return b;
    }
    constructor(){
        _define_property(this, "queue", void 0);
        _define_property(this, "bytesLen", void 0);
        _define_property(this, "insertedBytesLen", void 0);
        this.queue = createList();
        this.bytesLen = 0;
        this.insertedBytesLen = 0;
    }
}
class Extract {
    removePadding(size) {
        const padding = (512 - size % 512) % 512;
        if (padding > 0) {
            this.matrix.shift(padding);
            return padding;
        }
        return 0;
    }
    transport() {
        const decodeHead = ()=>{
            try {
                this.head = decode(this.matrix.shift(512), this.decodeOptions);
                if (this.head.typeflag === TypeFlag.XHD_TYPE) {
                    this.isPax = true;
                    return true;
                }
                if (Object.keys(this.paxMeta).length > 0) {
                    this.head.name = this.paxMeta.path;
                    this.head.linkname = this.paxMeta.linkpath;
                    // @ts-expect-error
                    this.head.pax = {
                        ...this.paxMeta
                    };
                    this.paxMeta = Object.create(null);
                }
                this.missing = this.head.size;
                this.elt = new Uint8Array(this.head.size);
                this.flag = true;
                this.offset = 0;
                return true;
            } catch (error) {
                this.writer.emit('error', error);
                return false;
            }
        };
        const consume = ()=>{
            const leak = this.missing > this.matrix.bytesLen;
            if (leak) {
                const b = this.matrix.shift(this.matrix.bytesLen);
                this.missing -= b.length;
                this.elt.set(b, this.offset);
                this.offset += b.length;
                return;
            }
            this.elt.set(this.matrix.shift(this.missing), this.offset);
            this.total += this.elt.length + 512;
            this.writer.emit('entry', this.head, this.elt);
            this.flag = false;
        };
        const handlePax = ()=>{
            const c = this.matrix.shift(this.head.size);
            const paxHead = decodePax(c);
            this.paxMeta = {
                ...this.paxMeta,
                ...paxHead
            };
            this.total += this.head.size + 512;
            this.isPax = false;
        };
        while(this.matrix.bytesLen > 0){
            if (this.isPax) {
                handlePax();
                continue;
            }
            if (this.flag) {
                consume();
                continue;
            }
            if (this.head && this.head.size && !this.flag) {
                const padding = this.removePadding(this.head.size);
                this.total += padding;
                this.head = Object.create(null);
                continue;
            }
            if (this.total + 1024 === this.matrix.insertedBytesLen) {
                this.matrix.shift(1024);
                return;
            }
            if (!decodeHead()) return;
        }
    }
    get receiver() {
        return this.writer;
    }
    on(event, listener = noop) {
        this.writer.on(event, listener);
    }
    constructor(options){
        _define_property(this, "writer", void 0);
        _define_property(this, "decodeOptions", void 0);
        _define_property(this, "matrix", void 0);
        _define_property(this, "head", void 0);
        _define_property(this, "missing", void 0);
        _define_property(this, "offset", void 0);
        _define_property(this, "flag", void 0);
        _define_property(this, "elt", void 0);
        _define_property(this, "total", void 0);
        _define_property(this, "isPax", void 0);
        _define_property(this, "paxMeta", void 0);
        this.decodeOptions = options;
        this.matrix = new FastBytes();
        this.head = Object.create(null);
        this.missing = 0;
        this.flag = false;
        this.offset = 0;
        this.elt = null;
        this.total = 0;
        this.isPax = false;
        this.paxMeta = Object.create(null);
        this.writer = createWriteableStream({
            write: (chunk, _, callback)=>{
                this.matrix.push(chunk);
                this.transport();
                callback();
            }
        });
    }
}
function createExtract(options = {}) {
    return new Extract(options);
}

export { D_MODE, ERROR_MESSAGES, F_MODE, Magic, Mode, TypeFlag, createExtract, createPack, decode, decodePax, encode, encodePax };
